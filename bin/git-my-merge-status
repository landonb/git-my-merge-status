#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/landonb/git-my-merge-status#🌵
# Copyright © 2020 Landon Bouma. All rights reserved.
# License: MIT. Please find more in the LICENSE file.

# ***

# USAGE: Run directly, or put on PATH and wire as alias.
#
#        - To set a git alias, run, e.g.:
#
#           $ git config --global alias.st '! git-my-merge-status'
#
#        - To set a Bash alias, run, e.g.:
#
#           $ alias st="git-my-merge-status"

# YOU: Run as-is, or customize to you liking via environs,
#      or by copy-pasting `my_merge_status_config`, below, to
#      your own wrapper script.

# DEPENDENCIES: None, but some optional.
#
# - If you'd like the output to show how old version tags are, install
#   a Python package published by the same author who wrote this script:
#
#     pip3 install human-friendly_pedantic-timedelta

# ***

# [HOLD ON, THIS'LL TAKE SOME EXPLAINING.]

# BASIC IDEA:
#
# Think of git-my-merge-status as `git status --porcelain` on steroids.
#
# CONCEPTS:
#
# In addition to letting you know if there's work to do in the working
# tree, such as if there are uncommitted files, my-merge-status also
# indicates if there's *workflow*-related work to do, such as needing
# to pull changes from a remote, or needing to merge a feature branch
# into a main development branch, or needing to push changes to a remote.
#
# As such, we'll need to clarify what we call each branch and each remote,
# and we'll need to define what purpose they each serve.
#
# REMOTE NAMES AND TERMS:
#
# - "RELEASE" REMOTE (the main project remote, sometimes called "upstream"):
#
#   The `git clone` command uses "origin" as the default remote name,
#   and users often clone their project fork first (without specifying
#   an alternative name with the `-o` option) before adding another
#   remote to point to the main project repository. So, generally, the
#   "origin" remote points to the user's fork. Then, when the user adds
#   a remote to the main project, they choose a different remote name,
#   and oftentimes that name is "upstream" (or at least that's the name
#   I often see used in examples online).
#
#   But, in a general sense, "upstream" can mean any remote where you push
#   changes. For instance, my GitHub repository (or any remote, for that
#   matter) is "upstream" of the local working tree on my machine. The term
#   might also be used to refer to a branch relationship, e.g., a "release"
#   branch might be considered *upstream* of a "development" branch, because
#   code flows *up* from the development branch into the release branch.
#
#   However, unlike "origin", which Git uses by default when you clone but
#   don't specify a remote name, the term "upstream" is not not codified
#   anywhere; it's just part of the vernacular. It's what the community
#   has come to name the remote that points to the main project repository.
#
#   As such, because "upstream" is used in different contexts and may have
#   different meanings, to avoid confusion, we'll call the main project
#   remote the "release" remote. This should ensure you have a clear idea
#   what we're talking about -- the "release" remote is the main project
#   repository.
#
# - "PROVING" REMOTE (your forked project remote, sometimes called "origin"):
#
#   Because Git defaults to using the name "origin" to label the remote
#   when you run the `git clone` command, and because people often clone
#   their own repository first (and then run `git remote add` to attach
#   the main project remote), we could use the name "origin" to refer to
#   the remote that the user owns and controls.
#
#   However, as with the "release" remote, to avoid ambiguity, we'll call
#   the forked project remote the "proving" remote, as in, you're proving
#   that your code works before you submit it to the release repository.
#
#   This way -- using two unique, precise terms, "proving" and "release" --
#   there should be no confusion as to which remote refers to what. The
#   "proving" remote refers to your fork, and the "release" remote refers
#   to the main project.
#
# - CUSTOM/ALTERNATIVE REMOTE NAMES:
#
#   If you'd like to use remote names other than those defined here, copy
#   the environment variable found below, GITSMART_MYST_REMOTE_HIERARCHY,
#   to a wrapper script that you call before you call this script, and
#   insert your preferred names as appropriate (or just edit the variable
#   below in your own copy of this script).
#
# - WHY "PROVING" and "RELEASE"?
#
#   The author finds the terms "origin" and "upstream" to be ambiguous,
#   and despite their widespread use, there's no consensus on their use.
#   So I find it safer to use more precise terms that are not commonly
#   used, which avoids the risk of confusing some users.
#
#   I like to think of the main project remote as the "release" remote,
#   and my GitHub user's fork of the project as the "proving" remote.
#   The term "release" is pretty obvious -- whatever code you're working
#   on is published from one source, and that's the "release". As for
#   "proving", this could just as well be "testing" or "development",
#   but by using "proving", we've chosen a word not normally used, so
#   there will be less confusion about what it means. This is the remote
#   where you prove that your code works, and after you've proven that,
#   then you can submit it to the main project for release.
#
#   As a bonus, these two words have the same number of letters, and,
#   when alphabetized, the main project remote is listed last, so a call
#   to `git remote -v` will list them in the logical order of how the code
#   flows (first to the "proving" remote, and then to the "release" remote);
#   and as a bonus, because the two names are the same width, the output is
#   more visually pleasant. E.g.,
#
#     $ git remote -v | grep push
#     proving git@github.com:my-user/some-project.git (push)
#     release git@github.com:the-org/some-project.git (push)
#
#   - (While it's being discussed, I may as well plug a better git-remote
#      formatter -- see the `git re` command in my git-smart project:
#
#        https://github.com/landonb/git-smart/blob/release/bin/git-re
#
#      The `git re` command only lists each remote once (unlike git-remote);
#      it orders the remotes based on the direction code flows (from remotes
#      listed first to remotes listed later); and it right-aligns the remote
#      names for prettier output.)
#
# BRANCH NAMES AND TERMS:
#
# - "PROGENITOR" TERM:
#
#   I use the term *progenitor*, defined as "an ancestor or parent", to refer
#   to the branch upstream [see the ambiguity of this term?] of the current
#   branch, where you are likely to want to merge changes.
#
#   (Note that "upstream" in the previous sentence refers to a branch, and
#   not a remote. So you see how "upstream" on its own is ambiguous -- it
#   might be used to refer to a remote, or it might be used to refer to a
#   branch. But I won't use "upstream" again except to refer to a remote.
#   So we'll talk about a remote as being upstream of another remote, and
#   we'll talk about a branch as being the progenitor of another branch.)
#
#   For instance, when I'm finished with a feature branch, I'll merge it to
#   the main development branch. And every so often, I'll merge that main
#   development branch to a release branch.
#
#   - So the development branch is a progenitor of the feature branch, and
#     the release branch is a progenitor of both the development branch and
#     any feature branch.
#
# - "PROVING" BRANCH (the main development branch, often called "main"):
#
#   What you name the various branches in a project is up to you. Many
#   people use the default name assigned by the Git tool as the name of
#   the main development branch, but this name, "master", is offensive.
#   The term is not meant in the "master copy" sense, but (if you look
#   at the history of Git itself) is a direct reference to the vulgar
#   and insensitive "master-slave" terminology adopted by early computer
#   scientists to describe a primary system and its associated replicas [1].
#
#   [1] Here's the first reference to 'master' in Git, from May 24, 2005:
#     https://github.com/git/git/commit/3e91311ae750af9bf2e3517b1e701288ac3066b9
#   The term was adopted from BitKeeper, e.g., this document from Feb 2, 2001:
#     https://github.com/bitkeeper-scm/bitkeeper/blob/master/doc/HOWTO.ask#L223
#   If you'd like to read more about the Git origin story, see here:
#     https://www.linuxjournal.com/content/git-origin-story
#
#   (As for why do I mention all this? As another person writes, and I totally
#    agree, "Language matters, but we often get used to saying things that
#    normalize harm. Certain phrases diminish or denigrate groups of people,
#    and if not addressed, these phrases become so commonplace that those
#    using them do not even consider their origins and effects."
#    - From "We need to stop saying ‘Ole Miss’" by Zach Borenstein.
#      https://thedmonline.com/opinion-we-need-to-stop-saying-ole-miss/
#   )
#
#   Git's default branch name is also imprecise because it does not tell you
#   what purpose the branch serves (is it a development branch, or is it a
#   release branch, or what?). But really we shouldn't use the term because
#   it's disgusting and offensive. So let's choose a different name.
#
#   For the sake of consistency, we'll call the main development branch
#   "proving", just as we call the forked project remote "proving". It's
#   where code goes first before going to "release".
#
#   (As an alternative, we could use another term that the community has
#   used in the past, such as "main", "trunk", "baseline", or "mainline".
#   But I find it easier to use the same two terms for branches as for
#   remotes. Then we can think of code flowing similarly, from proving to
#   release. We also avoid having four different names for essentially two
#   concepts, that of a place to prove your code works, and that of a place
#   from which to release your code. We've also picked two obvious names,
#   each of which on its own should be easy to understand, and each of
#   which is precise and unique enough to not be conflated with other
#   concepts.)
#
# - "RELEASE" BRANCH:
#
#   Every so often you'll merge the main body of work into a release branch,
#   that you'll then version and release. We'll call this branch -- no
#   surprise here -- the "release" branch.
#
# - CUSTOM/ALTERNATIVE BRANCH NAMES:
#
#   Just like with the remote names, you're free to choose your own branch
#   name scheme.
#
#   Look below for the GITSMART_MYST_REMOTE_HIERARCHY environment variable,
#   and either edit as appropriate, or copy to a wrapper script and edit.
#
# BRANCH AND REMOTE HIERARCHIES:
#
# - You might envision the progenitor branch hierarchy as
#   'release' <- 'proving' <- feature branches.
#
# - You might envision the remote repository hierarchy as
#   'release' <- 'proving' <- local repository.
#
# WORKFLOW:
#
# The code assumes a basic Forking Workflow, but with some specially-named
# branches for additional functionality I've found useful.
#
# Remotes:
# - If you've forked or cloned someone else's project, assign that URL
#   to the 'release' remote.
# - If you've forked a project, or if it's your personal project,
#   assign that URL to the 'proving' remote.
#   - If you didn't fork the project and it's not yours, do not use
#     a remote named 'proving'.
# - All other remotes are ignored.
#
# Branches:
# - Work flows from feature branches (named whatever you want) to the
#   'proving' branch, and from 'proving' to 'release'.
# - Use alpha or WIP (work in progress) branch naming to indicate that
#   a branch is not meant to be pushed to the remotes. The regex for
#   alpha/WIP branches is user-configurable but defaults to the prefixes "wip/"
#   and "a[0-9][0-9]/", e.g., "wip/testing-some-hack", or "a01/2020-03-13".
# - Use TIP (off the tip) branch naming to indicate that a branch is
#   allowed to be ahead of the remote branch (which is useful if you're
#   hacking on a fork but don't want to submit a pull request yet (or if
#   you never intend to)). A TIP branch starts with the prefix "tip/".
# - If you cannot name a branch specially and want to have it ignored by
#   this script (i.e., so you aren't needled to merge changes to 'proving',
#   because you checked out a pinned branch), you can add rules to the
#   ignore file (defined by GITSMART_MYST_NOCHORES_FILE).
#
# SYMBOLOGY:
#
# Here are the default icons and their significance,
#  where [symbol] means it's an alert, shown in red:
#
# -  🚽  a "private" repository, i.e., there's no remote with .com|.org|.etc.
#    🎁  a public repository, i.e., there's at least one .com|.org|.etc remote.
# - [👇] active branch is not tidy: has working tree changes, or untracked files.
#   [👊] active branch needs work: ahead of local ancestor, or has WIP or squash! commits;
#    🙏  active branch is pristine: at same commit as ancestor, and no WIP/squash commits.
#    🍬  active branch is a TIP branch, deliberately ahead of progenitor branch and 'release' remote.
#    🙈  chores are ignored per rule in GITSMART_MYST_NOCHORES_FILE (except tidiness).
# - [👆] active branch not pushed your 'proving' remote -- not shown for WIP branches.
#    👍  active branch at same commit as matching branch in 'proving' remote, e.g., refs/remotes/proving/<branch>.
# - [⚡] active branch not pushed to 'release' remote -- not shown for WIP or TIP branches.
#    🌩  active branch same commit as 'release' remote, e.g., refs/remotes/release/<branch>.
# -  ⛵  remote branch is ahead of local branch; user may want to fetch/pull changes.
#    🤷  for WIP branch, printed for each remote, because not expecting user to push.
#    ❗  for WIP, printed if the branch exists on the remote, which is unexpected.
#    🦘  for TIP branch, means there's no remote branch of same name (which is fine).
#    ❓  for TIP branch, means the remote branch exists, which would be strange.
# -  🏭  a WIP or "squash!" commit found between HEAD and the latest progenitor commit
# -  🌈  the all-good indicator: shown if active branch needs no work and is pushed.
#   [☻]  shaded to indicate what chores to do:
#        - Green: No chores. Working tree tidy, and progenitor and remote branches okay.
#        - Blue: User should merge the branch to progenitor or push to remote.
#        - Yellow: User needs to fetch changes from progenitor branch or remote.
#        - Red: Local repo is untidy; user must commit changes, add untracked, etc.
# -  🏷  if version tag found, shows how old it is (release early, release often!).
#    ☆   if no version tag, shows the age of the branch, since the first commit.
#
# CONVENTIONS:
#
# TYPES OF BRANCHES (AND HOW THEY'RE NAMED):
#
# All branches are optional, but each project might have any of the following:
# - A 'release' branch, which merges to no branch.
# - A 'proving' branch, which merges to 'release'.
# - Zero or more work-in-progress branches, aka WIP branches,
#   which eventually merge to 'proving' (if it exists) or 'release',
#   but probably after being rebased.
#   - A WIP branch is named with a prefix followed by the date.
#     The prefix is either 'wip/' or the letter 'a' (as in 'alpha')
#     followed by (generally) a 2-digit number you can increment. E.g.,
#     'wip/2020-03-10', or 'a01/2020-03-10' or 'a02/2020-03-10', etc.
#   - A WIP branch is generally not shared with other developers.
#     - I use WIP when I'm hacking on something that I plan to rebase
#       completely later (and then I'll either merge to, say, 'proving',
#       and push that to the remote, or I'll create a properly-named
#       branch and push that).
#     - The WIP branch naming convention could be used to tell other
#       developers not to take such a branch too seriously. But really
#       you should not push a WIP branch to a shared remote (like GitHub)
#       -- it feels like dirty underwear to me, so I like to keep it secret
#       -- so the my-merge-status tool will not check that a WIP branch has
#       been pushed to the 'proving' remote, like it does for other branches.
#       - If you are worried about backing up your work because you are
#         not pushing WIP branches to GitHub, consider using myrepos to
#         sync your work to a USB device or to another host when you want.
#     - In addition to using WIP branches for privately hacking without
#       judgement by others, I have a `git wip` alias that's useful
#       when I get interrupted and I want to capture my work -- it commits
#       all changes and any new files. Later, I'll `git rollback`, clean up
#       my work, and then make different commits. (For example, if I need
#       to physically leave my place and I've been working on my desktop
#       machine, I'll quickly git-wip my work, sync all my repos to a laptop,
#       and then I'm good to go -- I can rollback on the laptop and continue
#       working.)
#     - Considering how WIP branches are used privately, another reason not
#       to push a WIP branch to a public remote, such as GitHub, is because
#       you want to be able to rebase the branch, and you don't want to have
#       to force-push or worry about other developers working off your WIP.
#       - However, you might otherwise push a WIP branch, such that you won't
#         be able to rebase it without creating conflicts. For instance, I
#         use myrepos to backup locally, either to a USB thumb drive, or to
#         another host. Once I've backed up a WIP branch, I won't be able
#         to rebase it and back it up again without fiddling with the backup
#         repository. Ick. In cases such as this, I like to use the incremental
#         numbering strategy, mentioned earlier. For example, suppose I create
#         a WIP branch named "a01/2020-03-10", and that I push that branch to
#         backup media. Later, when I want to rebase that branch, to avoid a
#         conflict with the backup repo, I'll bump the alpha number and make a
#         new branch, e.g., "a02/2020-03-10".
# - Zero or more so-called "tipped", aka TIP, branches (where *tip* means
#   "attach to or cover the end or extremity of", as in, "mountains tipped
#   with snow"), which are used to fork-and-extend repositories where you
#   do not plan to submit changes upstream (e.g., you want to add an .ignore
#   to a project, but you don't want to bother project maintainers with a PR).
#   - Use the same naming convention as WIP branches, but the date should
#     reflect the date of the latest upstream commit that your work descends
#     from. I also like to add the eight-digit hash.
#     - For instance, if I forked a project whose last commit was 2019-08-14,
#       and whose hash is abcd1234, I'll create a branch named
#       "tip/2019-08-14-abcd1234" (and my-merge-status will show the
#       abbreviated form, "tip/2019-08-14", when reporting on multiple repos).
# - Zero or more so-called "feature" branches.
#   - A feature branch is conceptually the same as those defined in Gitflow.
#     These are branches you plan to share with others. You probably will not
#     want to rebase a feature branch (though you could always make a new
#     branch similarly named, but with a number incremented, or a different
#     date).
#   - Because feature branches are meant to be shared, my-merge-status will
#     notify you if the latest local feature branch commit has not been pushed
#     to the remote (e.g., if you have not yet pushed the latest commits to
#     the 'proving' remote).
#   - my-merge-status will also notify you if the feature branch has not
#     yet been merged to the *progenitor* branch (which is the 'proving'
#     branch if it exists, or 'release' branch (or whatever branch is
#     indicated by GITSMART_MYST_BRANCH_HIERARCHY)).
#   - So that a multiple-project my-merge-status shows the most relevant branch
#     name snippet (because the branch name space is limited), use the same
#     naming convention as used for WIP and TIP branches.
#     - In the feature branch name, include a 3-character prefix, followed by
#       a path separator, and then a 10-character date (YYYY-MM-DD), which can
#       be followed by anything except another path separator.
#       - For instance, here's how my-merge-status formats the following:
#           features/FOO-123/2020-03-10-drink-fizz-buzz → 123/2020-03-10
#           features/BAR-456/2020-03-10-add-magic-sauce → 456/2020-03-10
#         If you want to rebase your work but already shared the branch,
#         you could create a new branch using an incrementing number, and
#         the my-merge-status-reported branch name will remain the same, e.g.,
#           features/FOO-123/2020-03-10-drink-fizz-buzz-01 → 123/2020-03-10
#           features/FOO-123/2020-03-10-drink-fizz-buzz-02 → 123/2020-03-10
#       - (lb): I realize the three-character prefix might be limiting,
#         but I like it for its brevity. Consider setting the environment
#         variable, GITSMART_MYST_BR_PART_PENULTIMATE_W, if you'd like to
#         specify a different width.
# - Zero or more other branches, not named like or adhering to any previously
#   mentioned branch type.
#   - By default, my-merge-status assumes you'll want to eventually merge
#     these branches to the 'proving' or 'release' branch (i.e., to the
#     *progenitor* branch). So my-merge-status will alert you when these
#     branches are ahead of (or behind) the progenitor branch.
#     - If you want to tell my-merge-status to not check progenitor tidiness
#       on a repository, add the path to the repository to the file indicated
#       by GITSMART_MYST_NOCHORES_FILE (which is expected to be found
#       on PATH and defaults to '.my-merge-status-nochores').
#
# PUBLIC REMOTE DEFAULT BRANCHES:
#
# Consider setting the default branch on GitHub to help other users interpret
# your work.
# - The default branch on GitHub should be 'proving' if such a branch exists,
#   rather than 'release', so that someone who clones your repository gets
#   your latest work, and so that a Pull Request submitted to you defaults
#   to that branch as well.
# - If you're not using a 'proving' branch, stick with 'release' as the default.
# - But if the project is tipped, delete the 'release' branch both locally and
#   from the 'proving' remote, and set the GitHub default branch to the tipped
#   branch. This should give visitors to your GitHub page a better understanding
#   how you're using the forked project.
#   - Note that occasionally you'll want to fetch changes from the 'release'
#     remote. When changes are found, create a new TIP branch named as indicated
#     previously, rebase your work, push to your 'proving' remote, and then log on
#     GitHub and update the default branch. (MEH: Perhaps someday I'll automate
#     this step using a GitHub CLI tool.)
#
# REMOTE REPOSITORY CONVENTIONS:
#
# Considering the two conventional remote repositories, 'proving' and 'release':
# - Neither remote exists for private repositories.
# - If you've forked a project, the 'proving' remote refers to your GitHub
#   user's repository, and the 'release' remote refers to the repository
#   that was forked.
# - If you've cloned a project from another user or organization without
#   forking it first, the remote is named 'origin' by default. But I'll
#   often `git clone -o release` instead, so that the remote is called
#   'release', and so I'm reminded that the code is not my own.
# - You can name any other remotes as you see fit, e.g., if you are working
#   with another user and need access to their branches, you might add a
#   remote named with the same name as that user.
#   - my-merge-status only makes assumptions about the 'proving' and 'release'
#     remotes, and it ignores all other remotes.
#
# OTHER CONVENTIONS:
#
# To correctly identify private vs. public repos, my-merge-status looks
# for a .com, .org, or .edu in any remote name; or if a repo starts with "git@"
# which works for a default SSH URL, e.g., "git@github.com:landonb/git-my-merge-status",
# and also if you use the name of a Host from your ~/.ssh/config file.

# ***

# YOU: All customizable features are in this function.
# - See README for copy-paste code to setup a wrapper script for your user.
my_merge_status_config () {

  # *** Workflow 'names' and any name-specific icons.

  # Progenitor branches, e.g., check HEAD against 'develop' if feature branch,
  # 'develop' against 'release', and 'release' has no progenitor.
  GITSMART_MYST_BRANCH_HIERARCHY="${GITSMART_MYST_BRANCH_HIERARCHY:-release develop}"

  # - Each remote has three parts (so the array size is a multiple of 3):
  #   The first part is the remote name, followed by the icon used when the
  #   remote branch is up to date, then what icon to use if user should push.
  #   - E.g., "Hooray! 👍 The local and remote branch are at the same commit!",
  #     versus, "Hey, pal, you got work to do! Push your code 👆 up to the remote!"
  #   - The cloud and thunderbolt icon pairing is not as obvi. I associate cloud
  #     with community, i.e., the community that uses and works from the main
  #     source repository; and I guess the lighting bolt means you need to send
  #     a shock -- your bits! -- upstream to the organization repo.
  # - 2020-09-21: No go on '🐾', red on red.
  # - 2021-01-26: Ha, on macOS, paw prints are grey, which looks good.
  #   Hrmmm, we could detect OS to choose best defaults; or we could
  #   try to pick characters that look good on all OSes!
  #   Also, this might be font specific -- I use Hack font!
  GITSMART_MYST_REMOTE_HIERARCHY="${GITSMART_MYST_REMOTE_HIERARCHY:-release 👍 👆 protected 🌟 🌛}"

  # *** Other icons and config.

  GITSMART_MYST_HAS_PUBLIC_REMOTE="${GITSMART_MYST_HAS_PUBLIC_REMOTE:-🎁}"
  GITSMART_MYST_ALL_REMOTES_PRIVY="${GITSMART_MYST_ALL_REMOTES_PRIVY:-🚽}"
  GITSMART_MYST_LOOKS_PUBLIC_REGEX="${GITSMART_MYST_LOOKS_PUBLIC_REGEX:-^(ssh://git@|git@|https://)}"

  GITSMART_MYST_LOCAL_REPO_AGREE="${GITSMART_MYST_LOCAL_REPO_AGREE:-🙏}"
  GITSMART_MYST_LOCAL_REPO_AHEAD="${GITSMART_MYST_LOCAL_REPO_AHEAD:-👊}"
  GITSMART_MYST_LOCAL_REPO_MESSY="${GITSMART_MYST_LOCAL_REPO_MESSY:-👇}"
  GITSMART_MYST_LOCAL_REPO_NOCHR="${GITSMART_MYST_LOCAL_REPO_NOCHR:-🙈}"
  GITSMART_MYST_LOCAL_REPO_TIPBR="${GITSMART_MYST_LOCAL_REPO_TIPBR:-🍬}"

  GITSMART_MYST_PROGENITOR_AHEAD="${GITSMART_MYST_PROGENITOR_AHEAD:-⛵}"

  GITSMART_MYST_WIP_BRANCH_REGEX="${GITSMART_MYST_WIP_BRANCH_REGEX:-^alpha-.*,^wip/.*,^a[0-9]\\\+/.*}"
  # 'WIP' is my own convention. 'squash!' is from calls to `git commit --squash=<commit>`.
  GITSMART_MYST_WIP_COMMIT_REGEX="${GITSMART_MYST_WIP_COMMIT_REGEX:-^WIP(:|$),^squash!,^fixup!}"
  GITSMART_MYST_WIP_REMOTE_ABSENT="${GITSMART_MYST_WIP_REMOTE_ABSENT:-🤷}"
  GITSMART_MYST_WIP_REMOTE_EXISTS="${GITSMART_MYST_WIP_REMOTE_EXISTS:-❗}"
  GITSMART_MYST_WIP_COMMIT_FOUND="${GITSMART_MYST_WIP_COMMIT_FOUND:-🏭}"
  [ -z ${GITSMART_MYST_WIP_REMINDER+x} ] && \
    GITSMART_MYST_WIP_REMINDER="$(fg_tan)$(attr_emphasis)† WIP"
  # File with paths of repos whose up-branch tidiness to ignore,
  # e.g., if you checked out a release branch, say, 'release-1.0',
  # tell MYST to not worry about relationship to 'proving' branch.
  GITSMART_MYST_NOCHORES_FILE="${GITSMART_MYST_NOCHORES_FILE:-.my-merge-status-nochores}"

  GITSMART_MYST_TIP_BRANCH_REGEX="${GITSMART_MYST_TIP_BRANCH_REGEX:-^tip/}"
  # NOTE: The kangaroo eats up an addition column, not sure why, so appending space.
  GITSMART_MYST_TIP_UPSTREAM_ABSENT="${GITSMART_MYST_TIP_UPSTREAM_ABSENT:-🦘 }"
  GITSMART_MYST_TIP_UPSTREAM_EXISTS="${GITSMART_MYST_TIP_UPSTREAM_EXISTS:-❓}"

  GITSMART_MYST_ICON_ACHIEVEMENT="${GITSMART_MYST_ICON_ACHIEVEMENT:-🌈 }"
  GITSMART_MYST_ICON_TEMPERATURE="${GITSMART_MYST_ICON_TEMPERATURE:-☻}"

  # ∙: digraph `Sb`, Bullet Operator.
  GITSMART_MYST_SEP="${GITSMART_MYST_SEP:-∙}"
  GITSMART_MYST_TRIPLE_SEP="$(printf "${GITSMART_MYST_SEP}%.0s" {1..3})"
  GITSMART_MYST_SEPARATE_REMOTES="${GITSMART_MYST_SEPARATE_REMOTES:-}"
  # OPTIONAL: If you want to visually separate each of the remote icons, try, e.g.,:
  #   GITSMART_MYST_SEPARATE_REMOTES="${GITSMART_MYST_SEPARATE_REMOTES:- ${GITSMART_MYST_SEP} }"

  GITSMART_MYST_HIDE_AGE=${GITSMART_MYST_HIDE_AGE:-false}
  ! python_get_distribution "human-friendly_pedantic-timedelta" &> /dev/null && \
    GITSMART_MYST_HIDE_AGE=true
  # SYNC_ME: If you edit GITSMART_MYST_SINCE_VERSION_TAG, see `minwidth_fancy`, below.
  GITSMART_MYST_SINCE_VERSION_TAG="${GITSMART_MYST_SINCE_VERSION_TAG:-🏷}"
  # Pneumonic: A ☆ is born! The branch age, since the first commit.
  GITSMART_MYST_SINCE_INIT_COMMIT="${GITSMART_MYST_SINCE_INIT_COMMIT:-☆}"

  # landonb/ohmyrepos alignment (set true when running git-my-merge-status
  # against 100s of repos, so that columns align nicely).
  GITSMART_MYST_ALIGN_COLS=${GITSMART_MYST_ALIGN_COLS:-false}
  if ${GITSMART_MYST_ALIGN_COLS}; then
    GITSMART_MYST_ALIGN_NO_MERIT_FILLER="${GITSMART_MYST_ALIGN_NO_MERIT_FILLER:-   }"
  fi
  # The width of the second-to-last branch name (path) is 3 characters,
  # i.e., enough to fit a 'tip/' or 'wip/', or even an alpha-numbered
  # branch, e.g., 'a01/2020-03-10-new-idea', 'a02/2020-03-10', etc.
  GITSMART_MYST_BR_PART_PENULTIMATE_W=${GITSMART_MYST_BR_PART_PENULTIMATE_W:-3}
  # The width of the final branch name (path) part is 10 characters,
  # i.e., to fit a YYYY-MM-DD string.
  GITSMART_MYST_BR_PART_TERMINATING_W=${GITSMART_MYST_BR_PART_TERMINATING_W:-10}

  # aka GITSMART_MYST_TOO_COMFY but that name makes printfs really longer.
  [ -z ${TOO_COMFY+x} ] && ${GITSMART_MYST_ALIGN_COLS} && TOO_COMFY=' ' || TOO_COMFY=''
}

# ***

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# *** <beg boilerplate `source_deps`: ------------------------------|
#                                                                   |

readlink_f () {
  local resolve_path="$1"
  local ret_code=0
  if [ "$(readlink --version 2> /dev/null)" ]; then
    # Linux: Modern readlink.
    resolve_path="$(readlink -f -- "${resolve_path}")"
  else
    # macOHHHH-ESS/macOS: No `readlink -f`.
    local before_cd="$(pwd -L)"
    local just_once=true
    while [ -n "${resolve_path}" ] && ( [ -h "${resolve_path}" ] || ${just_once} ); do
      just_once=false
      local basedir_link="$(dirname -- "${resolve_path}")"
      # `readlink -f` checks all but final component exist.
      # So if dir path leading to final componenet missing, return empty string.
      if [ ! -e "${basedir_link}" ]; then
        resolve_path=""
        ret_code=1
      else
        local resolve_file="${resolve_path}"
        local resolve_link="$(readlink -- "${resolve_path}")"
        if [ -n "${resolve_link}" ]; then
          case "${resolve_link}" in
            /*)
              # Absolute path.
              resolve_file="${resolve_link}"
              ;;
            *)
              # Relative path.
              resolve_file="${basedir_link}/${resolve_link}"
              ;;
          esac
        fi
        local resolved_dir="$(dirname -- "${resolve_file}")"
        if [ ! -d "${resolved_dir}" ]; then
          resolve_path=""
          ret_code=1
        else
          cd "${resolved_dir}" > /dev/null
          resolve_path="$(pwd -P)/$(basename -- "${resolve_file}")"
        fi
      fi
    done
    cd "${before_cd}"
  fi
  [ -n "${resolve_path}" ] && echo "${resolve_path}"
  return ${ret_code}
}

# ***

source_deps () {
  local thispth="$1"
  local prefix=""
  local depsnok=false

  _source_it () {
    local prfx="${1:-.}"
    local depd="${2:-.}"
    local file="${3:-.}"
    local path="${prfx}/${depd}/${file}"
    if command -v "${file}" > /dev/null; then
      # Use version found on PATH.
      . "${file}"
    elif [ -f "${path}" ]; then
      # Fallback on local deps/ copy.
      # NOTE: `dash` complains if missing './'.
      . "${path}"
    else
      local depstxt=''
      [ "${prfx}" != "." ] && depstxt="in ‘${prfx}/${depd}’ or "
      >&2 echo "MISSING: ‘${file}’ not found ${depstxt}on PATH."
      depsnok=true
    fi
  }

  prefix="$(dirname -- "$(readlink_f "${thispth}")")"

  #                                                                 |
  # *** stop boilerplate> ------------------------------------------|

  # Load git_* funcs (e.g., git_branch_name), GITSMART_RE_GREPFILTER, etc.
  #  https://github.com/landonb/sh-git-nubs
  _source_it "${prefix}" "../deps/sh-git-nubs/bin" "git-nubs.sh"

  # *** <more boilerplate: -----------------------------------------|
  #                                                                 |

  ! ${depsnok}
}

#                                                                   |
# *** end boilerplate `source_deps`> -------------------------------|

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# ***

python_get_distribution () {
  local pkgname="$1"
  /usr/bin/env python3 -c \
    "from pkg_resources import get_distribution; \
     print(get_distribution('${pkgname}').version);"
}

# ***

os_is_macos () {
  [ "$(uname)" == "Darwin" ]
}

# ***

attr_emphasis () {
  printf "\e[3m"
}

attr_reset () {
  printf "\033[0m";
}

bg_jade () {
  printf "\033[48;2;0;175;95m"
}

bg_red () {
  # On @macOS, built-in red is pinkish, and bg red != fg red.
  #   printf "\033[41m"
  printf "\033[48;2;255;0;0m"
}

fg_green () {
  printf "\033[32m"
}

fg_lightblue () {
  printf "\033[94m"
}

fg_lightgray () {
  printf "\033[37m"
}

fg_lightgreen () {
  printf "\033[92m"
}

fg_lightyellow () {
  printf "\033[93m"
}

fg_red () {
  # On @macOS, built-in red is pinkish, and bg red != fg red.
  #   printf "\033[91m"
  printf "\033[38;2;255;0;0m"
}

fg_tan () {
  printf "\033[38;2;215;175;95m"
}

# For icon_party.

bg_party () {
  printf "\033[48;2;210;12;210m"
}

fg_party () {
  printf "\033[38;2;210;12;210m"
}

# ***

git_remote_looks_private () {
  local remote="$1"
  local remurl
  remurl="$(git remote get-url ${remote} 2> /dev/null)" || return 1
  ! $( echo "${remurl}" | grep -E "${GITSMART_MYST_LOOKS_PUBLIC_REGEX}" > /dev/null )
}

git_remotes_all_private () {
  local remote
  for remote in $(git remote); do
    ! git_remote_looks_private "${remote}" && return 1
  done
  return 0
}

# ***

# A "tipped" branch, or "tip" branch is the branch of a forked repo whose
# local changes have not made it upstream (yet) -- so you have to pull
# upstream changes and rebase local modifications on top, and thereby
# your local branch will *always* be ahead of refs/remotes/release/release.
branch_tipped () {
  local branch="$1"
  local tip_regex
  IFS=',' read -a tip_regex <<< "${GITSMART_MYST_TIP_BRANCH_REGEX}"
  local regex=''
  for regex in "${tip_regex[@]}"; do
    [[ ${branch} =~ ${regex} ]] && return 0
  done
  return 1
}

branch_is_local_alpha_or_wip () {
  local at_branch="${1:-${GITSMART_MYST_AT_BRANCH}}"

  [ -z "${GITSMART_MYST_WIP_BRANCH_REGEX}" ] && return 1

  local wip_greps
  IFS=',' read -a wip_greps <<< "${GITSMART_MYST_WIP_BRANCH_REGEX}"
  local grepclause
  for grepclause in "${wip_greps[@]}"; do
    ( echo "${at_branch}" | grep -e "${grepclause}" > /dev/null) && return 0
  done

  return 1
}

# ***

branch_ancestor () {
  local at_branch="${1:-${GITSMART_MYST_AT_BRANCH}}"
  local up_branch=''
  local it_branch
  for it_branch in ${GITSMART_MYST_BRANCH_HIERARCHY}; do
    [ "${at_branch}" = "${it_branch}" ] && break
    up_branch="${it_branch}"
  done
  # By workflow convention, current branch will eventually
  # make its way → ${up_branch}.
  echo "${up_branch}"
}

# You can ignore chores for a branch in a repository that you do not
# control (e.g., you've cloned someone else's project, and the "proving"
# branch is not synced to the "release" branch, but you cannot control
# this); and you can ignore chores for a branch that you specifically
# indicate is meant to be divergent from the progenitor branch (e.g.,
# you've pinned a branch to a specific commit and so therefore the
# branch is not expected to be merged into, say, "release").
no_up_branch_chores () {
  local project_root="$(git rev-parse --show-toplevel)"
  local exclude_file="$(command -v "${GITSMART_MYST_NOCHORES_FILE}")"
  ( [ -z "${exclude_file}" ] || [ ! -s ${exclude_file} ] ) && return 1
  local line
  while IFS= read -r line; do
    # Skip comment lines (completely unnecessary because strict regex later).
    [[ "${line}" =~ ^[[:space:]]*# ]] && continue
    # Look for match (the strict regex that is later).
    [[ "${line}" = "${project_root}" ]] && return 0
  done < "${exclude_file}"
  return 1
}

warn_up_not_ancestor () {
  local up_branch="$1"
  [ -z "${up_branch}" ] && return

  # Only warn if a conventional branch, i.e., not a feature or WIP branch,
  # or something private where we don't care if user will rebase.
  local it_matters=false
  local at_branch="${GITSMART_MYST_AT_BRANCH}"
  local it_branch
  for it_branch in ${GITSMART_MYST_BRANCH_HIERARCHY}; do
    [ "${at_branch}" = "${it_branch}" ] && it_matters=true && break
  done
  ! ${it_matters} && return

  if ! git show-branch ${up_branch} &> /dev/null; then
    >&2 printf '%b\n' "$(bg_red)WARNING: Oh gee! No progenitor at ${up_branch}!$(attr_reset)"
  # NOTE: Use refs/heads/ prefix to avoid "warning: refname '{}' is ambiguous",
  #       e.g., on macOS when remote is named same as branch.
  elif ! git merge-base --is-ancestor ${up_branch} HEAD 2> /dev/null; then
    # This could mean user rebased past ${up_branch}'s HEAD, which
    # would mean needing to writing an upstream branch's history to
    # commit changes. Which would probably be bad.
    >&2 printf '%b\n' "$(bg_red)WARNING: Whoops! History unrelated to ${up_branch}!$(attr_reset)"
  fi
}

# ***

python_prettify_elapsed () {
  local seconds="${1:-0}"
  # This spits to stderr if user does not have package installed.
  /usr/bin/env python3 -c \
    "from pedantic_timedelta import PedanticTimedelta; \
     pdtd = PedanticTimedelta(seconds=${seconds}); \
     print(pdtd.time_format_scaled(field_width=4, precision=1, abbreviate=4)[0]);" \
     2> /dev/null
}

git_last_version_tag_icon () {
  local commit_tags
  commit_tags="$(git --no-pager tag --points-at HEAD)"
  if [ -z "${commit_tags}" ]; then
    # The latest version tag is on an older commit (than HEAD).
    # Note that GITSMART_MYST_SINCE_VERSION_TAG (🏷) is two characters wide,
    # but in the console (at least @macOS iTerm2.app, and @linux mate-terminal)
    # it's only given one character width. As such, the first character that
    # follows the 🏷 will overlap it. Also, it affects lining up the column
    # with the other character used in it, ☆ (GITSMART_MYST_SINCE_INIT_COMMIT).
    # So we follow 🏷 with two spaces and lead with only 1, but for ☆ we lead
    # with two spaces and follow w/ 1, thereby right-aligning the two glyphs.
    # MEH/2021-01-27: (lb): I'm not super green on this business logic that
    # takes into account the glyph that GITSMART_MYST_SINCE_VERSION_TAG uses,
    # and that distinguishes between macOS vs. linux. (This could get messy!)
    if ! os_is_macos; then
      # Hack font on linux prints tag emoji (🏷) more centered/normally.
      printf "  ${GITSMART_MYST_SINCE_VERSION_TAG}  "
    else
      # The tag emoji (🏷) on @macOS is larger than @linux, and right-
      # justifies, or otherwise just looks better formatted thusly:
      printf " ${GITSMART_MYST_SINCE_VERSION_TAG}   "
    fi
  else
    local version_tags
    version_tags="$(echo "${commit_tags}" | grep -e "${GITSMART_RE_VERSION_TAG}")"
    if [ "$(echo "${version_tags}" | wc -l)" -eq 0 ]; then
      # Latest commit tagged, but not with a recognizable version string.
      printf " ${GITSMART_MYST_SINCE_VERSION_TAG}   "
    elif [ "$(echo "${version_tags}" | wc -l)" -ne 1 ]; then
      # More than 1 version tag found on latest commit!
      # Note: No space between glyphs. On both @linux and @macOS, the + overlaps
      #  the tag emoji on the rightside, looks kinda interesting.
      # MAYBE/2021-01-27: This might be Hack font-specific!
      # - TESTME: Try git-my-merge-status with other fonts.
      icon_alert "${GITSMART_MYST_SINCE_VERSION_TAG}➕"
    else
      # Perfect! The latest commit is versioned!
      icon_party "${GITSMART_MYST_SINCE_VERSION_TAG} ♪"
    fi
  fi
}

git_last_version_age () {
  ${GITSMART_MYST_HIDE_AGE} && echo ' ' && return 0
  # If not tagged, return whitespace padding, so final "WIP" column aligns.
  # - The hardcoded width here accounts for the leading 2 spaces in the final
  #   echo of this function, 1 space for the tag emoji (which, CAVEAT, means
  #   this feature easily breaks (the columns won't necessarily align) if the
  #   user edits GITSMART_MYST_SINCE_VERSION_TAG!), 2 more spaces, and `XX.X mons.`
  #   is the longest date string (10 chars) we'd see, plus there's 1 space after
  #   → 2+1+2+10+1=16.
  local minwidth_plain=16
  _print_filler () {
    # Such a funny Bash+printf trick. Bash expands the {1..n} to the list '1 2 3 ... n'
    # and then printf uses those as args to %s (without the 1..n, printf would print
    # once and exit), but we also truncate the arg value, %.0s, so printf doesn't
    # actually print the number from the list input, but instead just prints the
    # other format string parts (the space we want to repeat) over and over again.
    if ${GITSMART_MYST_ALIGN_COLS}; then
      eval "printf ' %.0s' {1..${minwidth_plain}}"
    else
      # Echo 2 spaces, like we'd do before the '🏷', below, so there's
      # brief emptiness between the previous column value (`☻`) and the
      # next value.
      echo "  "
    fi
  }
  local vtag_icon="$(git_last_version_tag_icon)"
  # - If tagged, enforce minwidth on tag string: we'll set the width on just
  #   the time portion, so ignore 5 characters from the previous calculation
  #   (the first 2 spaces, the '🏷', and the next 2 spaces)
  #   → 16-5 = 11.
  local minwidth_fancy=11
  # Get the epoch when the repo was last tagged.
  local tagtime
  tagtime=$(git_last_version_epoch_ts)
  # If not tagged, original code filled w/ spaces, so final "WIP" cells
  # aligned in their column, e.g.,
  #   [ $? -ne 0 ] && _print_filler && return 0
  # but we can do better! Show the age of the repository!
  if [ $? -ne 0 ]; then
    tagtime=$(git_since_init_epoch_ts)
    # Note the two leading spaces, because 1 character wide symbol (☆ vs 🏷),
    # and we want them to right-align.
    # - MAYBE/2021-01-26: Can/Should the code do the character width math?
    #   - If the user changes the environs, it could easily break formatting.
    #   - Currently, the code assumes:
    #       termwidth(GITSMART_MYST_SINCE_VERSION_TAG) == 2
    #       termwidth(GITSMART_MYST_SINCE_INIT_COMMIT) == 1
    #   - See: fill_placeholder, | wc --bytes, etc.
    vtag_icon="  ${GITSMART_MYST_SINCE_INIT_COMMIT}  "
  fi
  # No need to check $? again. #nofail
  # Determine the time elapsed between the tag (or init commit) and now.
  local nowtime=$(date +%s)
  local elapsed=$((nowtime - tagtime))
  local scaled_tm="$(python_prettify_elapsed ${elapsed})"
  # It used to be that there's no output if user does not have pedantic_timedelta
  # installed; but now we have a setup check that disables age reporting if it's
  # not installed. So now there's no output if the pedantic_timedelta call failed
  # (e.g., the API changed, but we didn't add a version check).
  [ -z "${scaled_tm}" ] && _print_filler && return 0
  # Ensure the time string is a minimum width, so later column values align.
  scaled_tm="$(eval "printf '%-${minwidth_fancy}s' '${scaled_tm}'")"
  local pretty_tm="$(fg_lightgray)$(attr_emphasis)${scaled_tm}$(attr_reset)"
  # The smiley face ☻ eats a space, so the 3 spaces here looks like 2 to users.
  printf '%b\n' " ${vtag_icon}${TOO_COMFY}${pretty_tm}"
}

# ***

prepare_part () {
  local part="$1"
  local width="$2"
  eval "printf '%-${width}s\n' '${part:0:${width}}'"
}

prepare_text_on_branch () {
  local name="${GITSMART_MYST_AT_BRANCH}"
  if ${GITSMART_MYST_ALIGN_COLS}; then
    # This is not the min-max algorithm my professor taught me. First,
    # truncate the string to the desired width, like max() to an int.
    # Then, expand the string to the desired width, like min().
    # N.O.T.E: Very Much Bash-specific code. Not POSIX.
    declare -a bparts
    IFS='/' read -a bparts <<< "${name}"
    if [ "${name}" != "${bparts[0]}" ] && [ ${#bparts} -ge 2 ]; then
      local penultimate="$(prepare_part "${bparts[-2]}" ${GITSMART_MYST_BR_PART_PENULTIMATE_W})"
      local terminating="$(prepare_part "${bparts[-1]}" ${GITSMART_MYST_BR_PART_TERMINATING_W})"
      name="${penultimate}/${terminating}"
    else
      # MAGIC_NUMBER: Add one for the '/' separator.
      local parts_and_sep_width=$((0 \
        + GITSMART_MYST_BR_PART_PENULTIMATE_W \
        + GITSMART_MYST_BR_PART_TERMINATING_W \
        + 1))
      name="$(prepare_part "${name}" ${parts_and_sep_width})"
    fi
  fi
  local on_branch="$(fg_lightblue)${name}$(attr_reset)"
  printf '%b\n' "${on_branch}"
}

# ***

prepare_icon_public_remotes () {
  # E.g., privy_icon=' 🎁'
  local privy_icon=" ${GITSMART_MYST_HAS_PUBLIC_REMOTE}"
  # E.g., privy_icon=" 🚽"
  git_remotes_all_private && \
    privy_icon=" ${GITSMART_MYST_ALL_REMOTES_PRIVY}"
  printf '%b\n' "${privy_icon}"
}

# ***

icon_alert () {
  _icon_alert () {
    printf '%b\n' "$(_alert_prefix)$(_alert_interior "${1}")$(_alert_suffix)"
  }

  _alert_prefix () {
    _alert_exterior '▐'  # Vim's 'RB' digraph.
  }

  _alert_suffix () {
    _alert_exterior '▌'  # Vim's 'lB' digraph.
  }

  _alert_exterior () {
    printf '%b\n' "$(fg_red)${1}$(attr_reset)"
  }

  _alert_interior () {
    printf '%b\n' "$(bg_red)${1}$(attr_reset)"
  }

  _icon_alert "${@}"
}

icon_party () {
  _icon_party () {
    printf '%b\n' "$(_alert_prefix)$(_alert_interior "${1}")$(_alert_suffix)"
  }

  _alert_prefix () {
    _alert_exterior '▐'  # Vim's 'RB' digraph.
  }

  _alert_suffix () {
    # Using full block helpful for icons that don't add width to line,
    # so that right side highlight gets clipped by the emoji character.
    # Which is to say, a hack for @macOS.
    _alert_exterior '█'  # Vim's 'FB' digraph.
  }

  _alert_exterior () {
    printf '%b\n' "$(fg_party)${1}$(attr_reset)"
  }

  _alert_interior () {
    printf '%b\n' "$(bg_party)${1}$(attr_reset)"
  }

  _icon_party "${@}"
}

# ***

CHORE_UNTIDY=1
CHORE_MERGE_UP_LOCAL=2
CHORE_PULL_DOWN_LOCAL=4
CHORE_REBASE_WIPS_LOCAL=8
CHORE_PUSH_UP_REMOTE=16
CHORE_PULL_DOWN_REMOTE=32

prepare_icon_synced_inner_self () {
  local syncodes=0
  # E.g., sync_icon=' 🙏 '
  local at_branch="${GITSMART_MYST_AT_BRANCH}"
  local up_branch="${GITSMART_MYST_UP_BRANCH}"
  local sync_icon=" ${GITSMART_MYST_LOCAL_REPO_AGREE} "
  # Whatever branch this is (including 'release', i.e., even branch with no
  # ancestor), always show alert icon if the active branch is not pristine.
  # Or, if there's a local upstream branch, show alert icon if the current
  # branch is ahead of that upstream local; unless current branch is tipped,
  # then show a different icon but don't mean it as an alert, just as info.
  if [ -n "$(git status --porcelain)" ]; then
    sync_icon="$(icon_alert "${GITSMART_MYST_LOCAL_REPO_MESSY}")"
    let "syncodes |= CHORE_UNTIDY"
  elif [ -n "${up_branch}" ]; then
    # NOTE: Use refs/heads/ prefix to avoid "warning: refname '{}' is ambiguous",
    #       e.g., on macOS when remote is named same as branch.
    if ! git merge-base --is-ancestor HEAD refs/heads/${up_branch}; then
      if no_up_branch_chores; then
        # The user made a rule to ignore local branch work for this project.
        sync_icon=" ${GITSMART_MYST_LOCAL_REPO_NOCHR} "
      elif branch_tipped "${at_branch}"; then
        # A "tip" branch has commits rebased on top of "release", but the commits
        # are not expected to be merged by the user to the local progenitor branch.
        sync_icon=" ${GITSMART_MYST_LOCAL_REPO_TIPBR} "
      else
        # E.g., sync_icon=' 👊 ', but with, e.g., bordered red background.
        sync_icon="$(icon_alert "${GITSMART_MYST_LOCAL_REPO_AHEAD}")"
        let "syncodes |= CHORE_MERGE_UP_LOCAL"
      fi
      warn_up_not_ancestor "refs/heads/${up_branch}"
    elif ! git merge-base --is-ancestor refs/heads/${up_branch} HEAD; then
      # Local branch is tidy; there exists a progenitor branch;
      # and the progenitor branch is ahead of this branch.
      # - Defaults to sailboat, ⛵, i.e., remote branch has sailed away.
      sync_icon=" ${GITSMART_MYST_PROGENITOR_AHEAD} "
      let "syncodes |= CHORE_PULL_DOWN_LOCAL"
    fi
  fi
  printf '%b\n' "${sync_icon}"
  return ${syncodes}
}

# ***

fill_placeholder () {
  local n_times=${1:-1}
  # Note:
  #     $ /usr/bin/env echo -n 🏷 | wc --chars
  #     1
  #     $ /usr/bin/env echo -n 🏷 | wc --bytes
  #     4
  #     # And same for 👍 and other Unicode characters.
  # But number of bytes is not the same as how many screen
  # columns each Unicode character typically uses, which is 2.
  # MAGIC_NUMBER(_of_spaces): space + 2-char-unicode + space = 4
  #                                                        1234
  #                                                        vvvv
  br_icons="$(eval "printf '${GITSMART_MYST_SEPARATE_REMOTES}    %.0s' {1..${n_times}}")"
  printf '%b\n' "${br_icons}"
}

# ***

# Indicate whether the branch is a WIP branch (local/private/alpha), meaning
# we don't care if the user has not pushed the branch to the remote -- show,
# e.g., a shrugging person 🤷 to indicate that the branch does not exist
# remotely ("who cares"), and show a question mark ❗ if it does exist (to
# tell user they might want to delete it).
remote_wip_icon () {
  local remote_branch_absent="$1"
  if ${remote_branch_absent}; then
    printf '%b\n' " ${GITSMART_MYST_WIP_REMOTE_ABSENT} "
  else
    printf '%b\n' " ${GITSMART_MYST_WIP_REMOTE_EXISTS} "
  fi
}

# ***

prepare_icon_synced_remote () {
  local remote="$1"
  local iconok="$2"
  local iconxx="$3"
  local diffco="$4"
  local syncodes=0
  local at_branch="${GITSMART_MYST_AT_BRANCH}"
  local sync_icon=" ${iconok} "
  local remote_branch_absent=false

  # Check that the branch exists on the remote.
  # Note that we don't want to make a network call, so avoiding, e.g.,
  #   git show-ref --verify --quiet refs/remotes/${remote}/${at_branch}
  # and well as `git ls-remote`.
  if ! git_remote_branch_exists "${remote}" "${at_branch}"; then
    # Default to placeholder "icon" (blank spaces).
    sync_icon="$(fill_placeholder "1")"
    remote_branch_absent=true
  fi

  if branch_is_local_alpha_or_wip "${at_branch}"; then
    sync_icon="$(remote_wip_icon "${remote_branch_absent}")"
  elif \
  # Note that merge-base fails if the first commit (branch) is not an ancestor
  # of the second commit (branch), but that it also fails if neither commit
  # (branch) exists, e.g., if the branch has not been pushed to the remote.
  # On the other hand, this call is successful if the two branches are at the
  # same commit, or if the latter is ahead of the former.
  ! git merge-base --is-ancestor ${diffco} refs/remotes/${remote}/${at_branch} \
    2> /dev/null
  then
    # If this is not the first remote we've checked (i.e., diffco is not HEAD,
    # so this is not the 'proving' remote, but the 'release' remote instead);
    # and if branch is tipped, e.g., 'tip/2020-03-09-abcd1234'; then not expecting
    # user to push to that remote; and showing a special icon instead.
    # 2020-03-23: Rather than check previous not 'HEAD' to infer this remote
    # is not the first remote, e.g., 'proving' remote, check the first remote
    # directly, e.g., not:
    #   if [ "${diffco}" != "HEAD" ] && branch_tipped "${at_branch}"; then
    # but the following instead (which works when, say, there is no 'proving'
    # remote, and ${diffco} is still 'HEAD' for multiple calls to this function):
    if [ "${remote}" != "${GITSMART_MYST_REMOTE_HIERARCHY[0]}" ] \
       && branch_tipped "${at_branch}"; \
    then
      # Local branch is tipped, e.g., tip/2020-03-09-abcd1234, and the
      # 'release' remote branch does not exist, or it's not up to date.
      if ${remote_branch_absent}; then
        # Preferable: this tipped branch may have been pushed to (e.g., my) 'proving'
        # remote, but it has not been pushed to (e.g., main project) 'release' remote.
        sync_icon=" ${GITSMART_MYST_TIP_UPSTREAM_ABSENT} "
      else
        # The branch exists further upstream than the user's main remote (per
        # GITSMART_MYST_REMOTE_HIERARCHY order), e.g., the remote is 'release';
        # and the branch on that remote is behind the local branch.
        # - (lb): This is not part of my workflow, so showing different, but not doing
        # anything else; this use case is unlikely/not expected given how I work(flow).
        sync_icon=" ${GITSMART_MYST_TIP_UPSTREAM_EXISTS} "
      fi
    else
      # Show the alert icon to tell user they probably want to push their branch to
      # the remote. Also verify that the user did not rebase themselves into a corner,
      # i.e., call merge-base like above, but with the parameters flipped, to verify
      # that the remote branch is an ancestor of this branch (otherwise, to merge
      # changes, user might have to force-push to the remote branch, egad!).
      sync_icon="$(icon_alert "${iconxx}")"
      let "syncodes |= CHORE_PUSH_UP_REMOTE"
      warn_up_not_ancestor "remotes/${remote}/${at_branch}"
    fi
  elif ! git merge-base --is-ancestor refs/remotes/${remote}/${at_branch} ${diffco} \
  2> /dev/null; then
    # The remote/branch is ahead of this remote/branch. ⛵ Come Sail Away.
    sync_icon=" ${GITSMART_MYST_PROGENITOR_AHEAD} "
    let "syncodes |= CHORE_PULL_DOWN_REMOTE"
  fi

  printf '%b\n' "${sync_icon}"
  return ${syncodes}
}

# ***

# Uses GITSMART_MYST_REMOTE_HIERARCHY, passed in as args.
prepare_icons_remotes () {
  local syncodes=0

  local re_icons=''

  # For each loop, compare the remote/branch against the previous remote/branch.
  # For the first time through, compare against $(git_branch_name) aka 'HEAD'.
  local currbr="${GITSMART_MYST_AT_BRANCH}"
  local diffco="HEAD"

  # Loop over the (branch, icon, icon) triplets.
  while [ "$1" != '' ]; do
    local remote="$1"
    local iconok="$2"
    local iconxx="$3"

    if [ -z "${remote}" ] || [ -z "${iconok}" ] || [ -z "${iconxx}" ]; then
      >&2 echo "ERROR: GITSMART_MYST_REMOTE_HIERARCHY malformed!"
      exit 1
    fi

    # Oddly, if you `shift n` more than there are args, nothing gets shifted.
    # To ensure `while` exits if args is not a multiple of 3, shift individually.
    # - Not safe: `shift 3`.
    shift 3

    local re_icon
    if git_remote_exists "${remote}"; then
      re_icon="$(prepare_icon_synced_remote "${remote}" "${iconok}" "${iconxx}" "${diffco}")"
      let "syncodes |= $?"
    elif ${GITSMART_MYST_ALIGN_COLS}; then
      # MAGIC_NUMBER: 4: Leading and trailing spaces, and two-column unicode character.
      re_icon="$(fill_placeholder "1")"
    else
      re_icon=''
    fi
    if [ -n "${re_icon}" ]; then
      re_icons="${TOO_COMFY}${re_icons}${GITSMART_MYST_SEPARATE_REMOTES}${re_icon}"
    fi
    # Only change diffco (previous reference branch) if it exists.
    if git_remote_branch_exists "${remote}" "${currbr}"; then
      diffco="${remote}/${currbr}"
    fi
  done

  printf '%b\n' "${re_icons}"

  return ${syncodes}
}

# ***

prepare_icons_branches () {
  local syncodes=0

  local br_icons=''
  br_icons="$(prepare_icon_synced_inner_self)"
  let "syncodes |= $?"

  br_icons="${br_icons}$(prepare_icons_remotes "${@}")"
  let "syncodes |= $?"

  printf '%b\n' "${br_icons}"
  return ${syncodes}
}

# ***

prepare_icons_rebasing () {
  # Echoes one icon for every WIP or SQ commit between branch and upbranch.

  # If no up-branch (i.e., on 'release' branch), do nothing.
  local up_branch="${GITSMART_MYST_UP_BRANCH}"
  [ -z "${up_branch}" ] && return

  # If no greps, do nothing,
  [ -z "${GITSMART_MYST_WIP_COMMIT_REGEX}" ] && return 0

  # Prepare the git-log "--grep" components.
  local wip_greps
  IFS=',' read -a wip_greps <<< "${GITSMART_MYST_WIP_COMMIT_REGEX}"
  local greps=''
  local grepclause
  for grepclause in "${wip_greps[@]}"; do
    greps="${greps} -E --grep \"${grepclause}\""
  done

  # (lb): Is there a better way to get the commit count? Use git-log's
  # --grep to match commit messages, and then use --pretty to ensure
  # there's just one matching line per match. And then count, wc -l.
  #
  # Note: --pretty=format: places newlines between commits. Use tformat to place
  # newlines after each commit. Otherwise there's no newline after last commit,
  # and we'd otherwise have to check empty string and return 0, or add 1 if not empty.
  #
  #   >&2 echo "git --no-pager log --pretty=tformat:\"%H\" ${greps} ${up_branch}..HEAD"
  #
  # 2020-09-01: (lb): On macOS (Git 2.28.0), in projects with remotes named same
  # as branch, e.g., remote 'release' and branch 'release', I see warnings, e.g.,
  #    $ git --no-pager log --pretty=tformat:\"%H\" ${greps} ${up_branch}..HEAD
  #    warning: refname 'release' is ambiguous
  # although it's not happening to same repos on Linux machines (Git 2.27.0).
  # You can see the refs, which match between machines.
  #    $ git show-ref
  #    abcd1234 refs/heads/release
  #    abcd1234 refs/remotes/release/release
  # which we can resolve with the more formal path, prefixed "refs/heads/".
  local wip_cnt
  wip_cnt=$( \
    eval "git --no-pager log --pretty=tformat:\"%H\" ${greps} refs/heads/${up_branch}..HEAD" \
    | wc -l \
  )

  [ ${wip_cnt} -eq 0 ] && return 0

  local wip_icon="${GITSMART_MYST_WIP_COMMIT_FOUND}"

  # - We could prints 1 emoji for each WIP counted
  #   e.g., 5 WIP commits would print:
  #     🏭 🏭 🏭 🏭 🏭
  #   - except it causes long lines and line breaks and doesn't help us align columns.
  # So we'll do so if not caring about column alignment.
  if ${GITSMART_MYST_ALIGN_COLS}; then
    # Show an abbreviated WIP report (that's less likely to be be very wide)
    # for the myrepos all-repos status report.
    eval "printf '${wip_icon}×%d' ${wip_cnt}"
  else
    eval "printf '${wip_icon} %.0s' {1..${wip_cnt}}"
  fi

  [ ${wip_cnt} -gt 255 ] && wip_cnt=255
  return ${wip_cnt}
}

# ***

prepare_icon_meritorious () {
  local syncodes="$1"
  local pt_sqwipes="$2"
  local wip_cnt="$3"
  local pt_rewip="$4"

  local pt_badge
  if [ ${syncodes} -eq 0 ]; then
    # E.g., icon="🛡", or "🌈", or whatever is set,
    # followed by a green face ☻ to indicate green.
    pt_badge="${GITSMART_MYST_ICON_ACHIEVEMENT}"
    pt_badge="${pt_badge}${TOO_COMFY}${TOO_COMFY}$(fg_lightgreen)${GITSMART_MYST_ICON_TEMPERATURE}"
  else
    # For multiple-repo reporting, show spaces instead of rainbow shield.
    local no_badge="${GITSMART_MYST_ALIGN_NO_MERIT_FILLER}"
    # Show a more mild alert if a WIP branch and the only
    # issue is that it needs to be merged to its progenitor.
    # - Award the user somewhat -- they should merge their
    #   branch, but otherwise their branch is in good shape.
    local tempcolor
    if [ $((${syncodes} & ${CHORE_UNTIDY})) -ne 0 ]; then
      # Red color icon: most important chore: user needs to tidy up
      # the working tree (commit changes, add untracked files, etc.).
      tempcolor="$(fg_red)"
    elif [ \
      $((${syncodes} & ( \
        ${CHORE_REBASE_WIPS_LOCAL} | ${CHORE_PULL_DOWN_LOCAL} | ${CHORE_PULL_DOWN_REMOTE} \
      ))) -ne 0 \
    ]; then
      # Light yellow: Chores of medium difficulty: user may need to rebase.
      # One or more local WIP branches need to be rebased; or the local
      # progenitor branch or a remote branch is ahead of the local branch.
      tempcolor="$(fg_lightyellow)"
    elif [ \
      $((${syncodes} & (${CHORE_MERGE_UP_LOCAL} | ${CHORE_PUSH_UP_REMOTE}))) -ne 0 \
    ]; then
      # Light blue: Easy chores: `merge --ff-only` and `push` work, should be easy.
      tempcolor="$(fg_lightblue)"
    fi
    pt_badge="${no_badge}${TOO_COMFY}${TOO_COMFY}${tempcolor}${GITSMART_MYST_ICON_TEMPERATURE}"
  fi
  pt_badge="${TOO_COMFY}${pt_badge}$(attr_reset)"

  local tripsep="${GITSMART_MYST_TRIPLE_SEP}"

  [ -n "${pt_sqwipes}" ] && pt_sqwipes=" ${pt_sqwipes}"

  local commendation=" ${tripsep}"
  ! ${GITSMART_MYST_ALIGN_COLS} && \
    commendation="${commendation}${pt_sqwipes}"
  commendation="${commendation} ${pt_badge}"

  # Preceeds the trips dot-dot-dot ∙∙∙
  printf '%b\n' "${commendation}"
}

# ***

prepare_extra_wip_reminder () {
  local wip_cnt="$1"
  local pt_sqwipes="$2"
  [ ${wip_cnt} -eq 0 ] && return
  local reminder="${GITSMART_MYST_WIP_REMINDER}"
  ${GITSMART_MYST_ALIGN_COLS} && \
    reminder=" ${reminder}:${pt_sqwipes}$(attr_reset)"
  printf '%b\n' "${reminder}$(attr_reset)"
}

# ***

prepare_branch_report () {
  GITSMART_MYST_AT_BRANCH="$(git_branch_name)"

  GITSMART_MYST_UP_BRANCH="$(branch_ancestor "${GITSMART_MYST_AT_BRANCH}")"
  while true \
    && [ -n "${GITSMART_MYST_UP_BRANCH}" ] \
    && ! git_branch_exists "${GITSMART_MYST_UP_BRANCH}" \
  ; do
    GITSMART_MYST_UP_BRANCH="$(branch_ancestor "${GITSMART_MYST_UP_BRANCH}")"
  done

  local pt_local
  local pt_privy
  local pt_branches
  local pt_sqwipes

  # We use subshells to make returning text easy, but then it makes passing
  # other information difficult. Which is why we cue off the return code to
  # track syncodes.
  local syncodes=0
  pt_local="$(prepare_text_on_branch)"
  pt_privy="$(prepare_icon_public_remotes)"
  pt_merge="$(prepare_icons_branches "${@}")" || let "syncodes |= $?"
  local wip_cnt=0
  pt_sqwipes="$(prepare_icons_rebasing)" || let "wip_cnt += $?"
  [ ${wip_cnt} -eq 0 ] || let "syncodes |= CHORE_REBASE_WIPS_LOCAL"
  local pt_merit="$(prepare_icon_meritorious "${syncodes}" "${pt_sqwipes}" "${wip_cnt}")"
  local pt_vrage="$(git_last_version_age)"
  local pt_rewip="$(prepare_extra_wip_reminder "${wip_cnt}" "${pt_sqwipes}")"

  printf '%b\n' "${pt_local}${TOO_COMFY}${TOO_COMFY}${pt_privy} ${TOO_COMFY}${TOO_COMFY}${GITSMART_MYST_SEP}${TOO_COMFY} ${pt_merge}${pt_merit}${pt_vrage}${pt_rewip}"
}

# ***

print_branch_report () {
  # Set default args, unless user passed.
  [ "${#}" -eq 0 ] && \
    set -- ${GITSMART_MYST_REMOTE_HIERARCHY}
  prepare_branch_report "${@}"
}

# ***

my_merge_status_report () {
  print_branch_report "${@}"
  git status --short
}

# ***

main () {
  source_deps "${BASH_SOURCE[0]}" || exit 1
  local before_cd="$(pwd -L)"
  # So that a git alias works, which run !commands from top-level, cd maybe.
  [ -n "${GIT_PREFIX}" ] && cd "${GIT_PREFIX}"
  my_merge_status_config
  my_merge_status_report "${@}"
  cd "${before_cd}"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  main "${@}"
fi

